<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="hu"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">menu</a> &gt; <a href="index.source.html" class="el_package">org.example.map</a> &gt; <span class="el_source">MapValidator.java</span></div><h1>MapValidator.java</h1><pre class="source lang-java linenums">/**
 * Provides utility methods for validating game maps.
 */
package org.example.map;
import java.util.List;

/**
 * Checks if the map size is valid (between 6x6 and 20x20).
 */
<span class="nc" id="L10">public class MapValidator {</span>
    /** Minimum valid map size. */
    private static final int MIN_MAP_SIZE = 6;
    /** Maximum valid map size. */
    private static final int MAX_MAP_SIZE = 20;
    /**
     * Checks if the map size is valid (between 6x6 and 20x20).
     * @param size The size of the map.
     * @return true if the map size is valid, false otherwise.
     */
    public static boolean isValidMapSize(final int size) {
<span class="pc bpc" id="L21" title="2 of 4 branches missed.">        return size &gt;= MIN_MAP_SIZE &amp;&amp; size &lt;= MAX_MAP_SIZE;</span>
    }

    /**
     * Checks and prints details from the map header.
     * @param header The map header string.
     */
    public static void checkAndPrintHeaderDetails(final String header) {
<span class="pc bpc" id="L29" title="2 of 4 branches missed.">        if (header != null &amp;&amp; header.length() &gt;= 3) {</span>
<span class="fc" id="L30">            char firstnumber = header.charAt(0);</span>
<span class="fc" id="L31">            char secondChar = header.charAt(2);</span>
<span class="fc" id="L32">            char thirdChar = header.charAt(4);</span>
<span class="fc" id="L33">            char lastChar = header.charAt(header.length() - 1);</span>
          //  System.out.println(&quot;A fejléc második karaktere: &quot; + firstnumber);
          //  System.out.println(&quot;A fejléc második karaktere: &quot; + secondChar);
          //  System.out.println(&quot;A fejléc harmadik karaktere: &quot; + thirdChar);
          //  System.out.println(&quot;A fejléc negyedik karaktere: &quot; + lastChar);
        }
<span class="fc" id="L39">    }</span>
    /**
     * Validates map dimensions based on the map lines and header.
     * @param mapLines The lines of the map.
     * @param header The map header string.
     * @return true if map dimensions are valid, false otherwise.
     */
    public static boolean isValidMapDimensions(
            final List&lt;String&gt; mapLines,
            final String header) {
<span class="pc bpc" id="L49" title="3 of 6 branches missed.">        if (mapLines == null || mapLines.isEmpty()</span>
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">                || header == null || header.isEmpty()) {</span>
<span class="nc" id="L51">            return false;</span>
        }
        // Keresd meg az első nem számjegy karakter pozícióját a fejlécben
<span class="fc" id="L54">        int firstNonDigitIndex = 0;</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">        while (firstNonDigitIndex &lt; header.length()</span>
                &amp;&amp;
<span class="fc bfc" id="L57" title="All 2 branches covered.">                Character.isDigit(header.charAt(firstNonDigitIndex))) {</span>
<span class="fc" id="L58">            firstNonDigitIndex++;</span>
        }
        // Ha nincs szám a fejlécben, akkor téves a méret
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (firstNonDigitIndex == 0) {</span>
<span class="nc" id="L62">            return false;</span>
        }
        // Alakítsd át a számjegyeket számmá
        int expectedSize;
        try {
<span class="fc" id="L67">            expectedSize = Integer.parseInt(</span>
<span class="fc" id="L68">                    header.substring(0, firstNonDigitIndex)</span>
            );
<span class="nc" id="L70">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L71">            return false; // Ha a számjegyek nem alakíthatók át érvényes számmá</span>
<span class="fc" id="L72">        }</span>
<span class="fc" id="L73">        int rowCount = mapLines.size();</span>
<span class="fc" id="L74">        int colCount = mapLines.get(0).length();</span>
<span class="pc bpc" id="L75" title="2 of 4 branches missed.">        return rowCount == expectedSize &amp;&amp; colCount == expectedSize;</span>
    }

    /**
     * Checks if the map is surrounded by walls.
     * @param mapLines The list of strings representing the map.
     * @return True if the map is surrounded by walls, false otherwise.
     */
    public static boolean isSurroundedByWalls(final List&lt;String&gt; mapLines) {
<span class="pc bpc" id="L84" title="2 of 4 branches missed.">        if (mapLines == null || mapLines.isEmpty()) {</span>
<span class="nc" id="L85">            return false;</span>
        }
<span class="fc" id="L87">        int rowCount = mapLines.size();</span>
<span class="fc" id="L88">        int colCount = mapLines.get(0).length();</span>
        // Ellenőrizzük az első és utolsó sort
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (!isRowFullOfWalls(mapLines.get(0))</span>
                ||
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">                !isRowFullOfWalls(mapLines.get(rowCount - 1))) {</span>
<span class="nc" id="L93">            return false;</span>
        }
        // Ellenőrizzük a többi sort
<span class="fc bfc" id="L96" title="All 2 branches covered.">        for (int i = 1; i &lt; rowCount - 1; i++) {</span>
<span class="fc" id="L97">            String row = mapLines.get(i);</span>
<span class="pc bpc" id="L98" title="2 of 4 branches missed.">            if (row.length() != colCount || row.charAt(0) != 'W'</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">                    || row.charAt(colCount - 1) != 'W') {</span>
<span class="nc" id="L100">                return false;</span>
            }
        }
<span class="fc" id="L103">        return true;</span>
    }

    /**
     * Checks if a given row consists entirely of walls ('W').
     * @param row The row to check.
     * @return true if the row is full of walls, false otherwise.
     */
    private static boolean isRowFullOfWalls(final String row) {
<span class="fc bfc" id="L112" title="All 2 branches covered.">        for (char c : row.toCharArray()) {</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if (c != 'W') {</span>
<span class="nc" id="L114">                return false;</span>
            }
        }
<span class="fc" id="L117">        return true;</span>
    }
    /**
     * Calculates the number of Wumpus creatures based on map size.
     * @param mapSize The size of the map.
     * @return The number of Wumpus creatures.
     */
    public static int wumpusCount(final int mapSize) {
<span class="fc" id="L125">        final int wumpusZero = 6;</span>
<span class="fc" id="L126">        final int wumpusOne = 8;</span>
<span class="fc" id="L127">        final int wumpusTwo = 14;</span>
<span class="fc" id="L128">        final int wumpusThree = 3;</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (!isValidMapSize(mapSize)) {</span>
<span class="nc" id="L130">            System.out.println(&quot;Invalid map size: &quot; + mapSize);</span>
        }
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (mapSize &lt; wumpusZero) {</span>
<span class="nc" id="L133">            return 0;</span>
        }
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (mapSize &lt;= wumpusOne) {</span>
<span class="nc" id="L136">            return 1;</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        } else if (mapSize &lt;= wumpusTwo) {</span>
<span class="fc" id="L138">            return 2;</span>
        } else {
<span class="nc" id="L140">            return wumpusThree;</span>
        }
    }
    /**
     * Checks if the map contains exactly one gold piece.
     * @param mapLines The lines of the map.
     * @return true if the map contains
     * exactly one gold piece, false otherwise.
     */
    public static boolean hasExactlyOneGold(final List&lt;String&gt; mapLines) {
<span class="fc" id="L150">        int goldCount = 0;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (String line : mapLines) {</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">            for (char c : line.toCharArray()) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">                if (c == 'G') {</span>
<span class="fc" id="L154">                    goldCount++;</span>
                }
            }
<span class="fc" id="L157">        }</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        return goldCount == 1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>